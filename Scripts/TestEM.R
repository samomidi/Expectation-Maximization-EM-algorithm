#Assignment 2
#Team K
# Testing Functions ----------------------------------------------------------------


kurtosis.test <- function (data) {
  # Purpose: Testing normality of the generated distribution according to kurtosis algorithm.
  #   The kurtosis describes the tail shape of the data distribution. 
  #   The normal distribution has zero kurtosis and thus the standard tail shape.
  # Input:
  #   data - dataframe of observations
  # Output:
  #   pvalue - single variable pvalue
  
  x <- teamEM(data)
  p <- x$Posterior
  m4 <- sum((data$Length-p[, 1] ^ 4)/length(data$Length))
  s4 <- p[, 2]
  kurt <- (m4 / s4) - 3
  sek <- sqrt(24/ data$Length)
  totest <- kurt / sek
  pvalue <- pt(totest, (data$Length - 1))
  # Returning the P-value and checking how close it is to zero
  return(pvalue)
}


dataframe <- function (size, ages) {
  # Purpose: Simulates random Gaussian mixture dataframes
  # Inputs:
  #   size - single value for the number of observations
  #   ages - single value for the number of groups
  # Outputs:
  #   data - dataframe with columns for ID, observation, and the group value 
  #     ,if known, for each observation (row)
  
  # Initialise the columns of the dataframe
  Length <- rep(0, size)
  Age <- rep(0, size)
  FishID <- c(1:size)
  
  groupsize <- floor(size / ages)
  
  # Creates Normal random deviates given size and age and puts them into the Length vector
  for (i in 1:(ages - 1)) {
    Length[((i - 1) * groupsize + 1):(i * groupsize)] <- rnorm(groupsize, 10 * i, 2 * i)
  }
  difference <- size - groupsize * ages
  #   Note: When the dataframe is returned there is a warning saying that the
  #   length of rnorm is incorrect. We cannot see why the length is wrong,
  #   and the function is still returning the dataframe as it is just a warning,
  #   not an error
  Length[((ages - 1) * groupsize + 1):size] <- rnorm(groupsize + difference, 10 * ages, 2 * ages)
  
  # Creates a mixture of known and unknown groups and putting them into the Age vector
  for (i in 1:size) {
    for (j in 1:(ages - 1)) {
      if (i >= ((j - 1) * groupsize + 1) && i <= (j * groupsize)) {
        Age[i] <- sample(c(NA, NA, NA, j), 1)
      } 
    }
    if (identical(Age[i], 0)) {
      Age[i] <- sample(c(NA, NA, NA, ages), 1)
    }
  }
  
  data <- data.frame(FishID, Length, Age)
  return(data)
}

TestTeamEM <- function(data, epsilon = 1e-08, maxit = 1000, include = FALSE){
  # Purpose:
  #   Testing the teamEM function
  # Inputs: 
  #   data - the dataframe of all the observations
  #   epsilon - tolerance value, with a default value 1e-08
  #   maxit - the maximum number of iterations, with a default value 1000
  #   include - a boolean value, letting the user decide whether to use the 
  #     known probabilities in the EM algorithm (enhancement)
  # Outputs:
  #  TRUE or FALSE
  
  teamEM.result <- teamEM(data, epsilon, maxit, include)
  
  # check if the length of the returned values are equal to 5
  if(length(teamEM.result) != 5){
    return(FALSE)
  }
  
  # Check if the returned value contains the required information
  if(!all(c("Estimates", "Inits", "Converged", "Posterior", "Likelihood") == names(teamEM.result))){
    return(FALSE)
  }
  
  # Check if the likelihood is numeric
  if (!is.numeric(teamEM.result$Likelihood)) {
    return(FALSE)
  }
  
  # check if the posterior values are between 0 and 1 (probabilities)
  posterior.res <- as.vector(teamEM.result$posterior)
  if (any(posterior.res < 0) | any(posterior.res > 1)) {
    return(FALSE)
  }
  
  if (!identical(data$Length, data[,2]) | !identical(data$Age, data[,3])) {
    print("here")
    return(FALSE)
  } 
  
  return(TRUE)
}


pairedttest <- function (data) {
  # Purpose: Tests whether the parameter estimates generated by teamEM() is drawn from 
  #   a normal distribution using paired t-test - teamEM() should return the correct response
  # Inputs:
  #   data - a dataframe of observations
  # Outputs:
  #   pvalue - a single pvalue: the higher the pvalue, the closer the parameter 
  #     estimates are to the correct estimates returned from normalmixEM
  # Note: 
  #   produces a warning when there are identical observations in the dataset
  #   loaded in mixtools library to use normalmixEM to find the true parameter estimates
  
  group <- max(data[, 3], na.rm = TRUE)
  t <- teamEM(data)
  known <- normalmixEM(data[, 2], k = group)

  # Carries out paired t-tests on each parameter estimate
  mu <- t.test(t$Estimates[, 1], known$mu, paired = TRUE)
  sigma <- t.test(t$Estimates[, 2], known$sigma, paired = TRUE)
  lambda <- t.test(t$Estimates[, 3], known$lambda, paired = TRUE)
  
  list <- list(mu, sigma, lambda)
  names(list) <- c("mu", "sigma", "lambda")
  return(list)
}


normality.test <- function(data) {
  # Purpose: Tests whether the data comes from a Gaussian distribution using the 
  #   D'Agostino-Pearson omnibus test which looks at skewness and kurtosis. Will 
  #   calculate how far each value differs from the expected Gaussian distribution.
  #   If p-value is small, then reject the null hypothesis (data not consistent 
  #     with a Gaussian distribution).
  #   Decided against Shapiro-Wilk test as it does not work with repeated values of observations.
  # Inputs:
  #   data - dataframe of observations
  # Outputs:
  #   pvalue - a list of pvalues for the omnibus, skewness and kurtosis tests

  return(dagoTest(data[, 2]))
}


component.test <- function(data, max.comp) {
  # Purpose: Tests whether the number of groups is appropriate for the data by bootstrapping
  # Inputs:
  #   data - dataframe of observations
  #   max.comp - maximum number of components to test for (default = 2)
  # Outputs:
  #   TRUE or FALSE
  # Note:
  #   boot.comp is a function from the library mixtools
  
  a <- boot.comp(y = data[, 2], max.comp = max.comp, B = 100, mix.type = "normalmix", epsilon = 1e-6)
  if (length(a$p.values) == max(data[, 3], na.rm = TRUE)) {
    return(TRUE)
  }
  else {
    return(FALSE)
  }
}

